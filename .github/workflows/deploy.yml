on:
  # Deploy pipeline trigger on deploy branch pushes.
  push:
    branches:
      - deploy

  # Also trigger when PR is merged into deploy.
  pull_request:
    branches:
      - deploy
    types:
      - closed

  # Manual fallback trigger.
  workflow_dispatch:

permissions:
  contents: read
  packages: write

# Avoid overlapping deploys for the same effective commit.
concurrency:
  group: deploy-${{ github.workflow }}-${{ github.event.pull_request.merge_commit_sha || github.sha }}
  cancel-in-progress: true

env:
  NODE_VERSION: "20"

jobs:
  ci:
    name: CI
    runs-on: ubuntu-latest
    if: >
      (github.event_name == 'push' && github.ref == 'refs/heads/deploy') ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'deploy')
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Guardrail: prevent direct pushes to deploy from bypassing PR flow.
      # This does not replace GitHub branch protection; it adds runtime enforcement.
      - name: Guard deploy branch policy (require merged PR on push)
        if: github.event_name == 'push' && github.ref == 'refs/heads/deploy'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.sha;
            const response = await github.request(
              "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
              {
                owner,
                repo,
                commit_sha: sha,
                mediaType: { previews: ["groot"] }
              }
            );
            const mergedToDeploy = response.data.some(
              (pr) => pr.base?.ref === "deploy" && Boolean(pr.merged_at)
            );
            if (!mergedToDeploy) {
              core.setFailed(
                "Direct push detected on deploy branch. Merge through PR only."
              );
            }
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: |
            package-lock.json
            Client/package-lock.json
            Server/package-lock.json
      # Explicit node_modules cache as requested.
      - name: Cache node_modules (root + client + server)
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            Client/node_modules
            Server/node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('package-lock.json', 'Client/package-lock.json', 'Server/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-
      - name: Inject optional CI env files
        run: |
          set -euo pipefail
          if [ -n "${{ secrets.SERVER_ENV_FILE }}" ]; then
            printf "%s" "${{ secrets.SERVER_ENV_FILE }}" > Server/.env
          fi
          if [ -n "${{ secrets.CLIENT_ENV_FILE }}" ]; then
            printf "%s" "${{ secrets.CLIENT_ENV_FILE }}" > Client/.env.local
          fi
      - name: Install dependencies
        run: |
          set -euo pipefail
          npm ci
          npm --prefix Client ci
          npm --prefix Server ci
      - name: Verify npm ci lockfile determinism
        run: |
          set -euo pipefail
          git diff --exit-code -- package-lock.json Client/package-lock.json Server/package-lock.json
      - name: Run ESLint
        run: |
          set -euo pipefail
          npm --prefix Client run lint
          if npm --prefix Server run | grep -qE '^  lint'; then
            npm --prefix Server run lint
          else
            echo "No server lint script found; skipping server lint."
          fi
      - name: Run TypeScript type check
        run: |
          set -euo pipefail
          npm --prefix Client run typecheck
      - name: Guard explicit any regressions
        run: |
          set -euo pipefail
          npm run quality:any
      - name: Run tests
        run: |
          set -euo pipefail
          if npm --prefix Client run | grep -qE '^  test'; then
            npm --prefix Client run test
          else
            echo "No client test script found; skipping client tests."
          fi
          npm --prefix Server run test -- --silent
      - name: Build frontend (Next.js production build)
        run: |
          set -euo pipefail
          npm --prefix Client run build
      - name: Build backend / runtime validation
        run: |
          set -euo pipefail
          if npm --prefix Server run | grep -qE '^  build'; then
            npm --prefix Server run build
          else
            echo "No backend build script found; running syntax checks."
            find Server -path 'Server/node_modules' -prune -o -name "*.js" -print0 | xargs -0 -n1 node --check
          fi
      # Build once, deploy artifact: deterministic and lighter server deploy.
      - name: Package deployment artifact
        run: |
          set -euo pipefail
          rm -rf _release
          mkdir -p _release
          # Copy repository while excluding CI-time/runtime noise.
          rsync -a ./ _release/ \
            --exclude '.git' \
            --exclude '.github' \
            --exclude 'node_modules' \
            --exclude 'Client/node_modules' \
            --exclude 'Server/node_modules' \
            --exclude 'Server/.env' \
            --exclude 'Client/.env.local' \
            --exclude 'Server/tests' \
            --exclude 'Server/advTest' \
            --exclude '*.log'
          # Ensure frontend build output exists in artifact.
          test -d _release/Client/.next
          tar -czf "release-${GITHUB_SHA}.tar.gz" -C _release .
      - name: Upload deployment artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ github.sha }}
          path: release-${{ github.sha }}.tar.gz
          retention-days: 7

  deploy_pm2:
    name: CD (PM2, release artifact + rollback)
    runs-on: ubuntu-latest
    needs: ci
    if: needs.ci.result == 'success'
    environment:
      name: production

    steps:
      - name: Download deployment artifact
        uses: actions/download-artifact@v4
        with:
          name: release-${{ github.sha }}
          path: .

      - name: Upload artifact to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || '22' }}
          fingerprint: ${{ secrets.SSH_FINGERPRINT }}
          source: release-${{ github.sha }}.tar.gz
          target: /tmp

      - name: Deploy artifact via SSH (blue/green-style release dirs)
        uses: appleboy/ssh-action@v1.0.3
        env:
          APP_PATH: ${{ secrets.SERVER_APP_PATH }}
          DEPLOY_SHA: ${{ github.sha }}
          HEALTHCHECK_URL: ${{ secrets.HEALTHCHECK_URL }}
          SERVER_ENV_FILE: ${{ secrets.SERVER_ENV_FILE }}
          CLIENT_ENV_FILE: ${{ secrets.CLIENT_ENV_FILE }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || '22' }}
          fingerprint: ${{ secrets.SSH_FINGERPRINT }}
          envs: APP_PATH,DEPLOY_SHA,HEALTHCHECK_URL,SERVER_ENV_FILE,CLIENT_ENV_FILE
          script_stop: true
          timeout: 25m
          script: |
            set -Eeuo pipefail
            APP_ROOT="${APP_PATH}"
            RELEASES_DIR="${APP_ROOT}/releases"
            CURRENT_LINK="${APP_ROOT}/current"
            NEW_RELEASE="${RELEASES_DIR}/${DEPLOY_SHA}"
            ARTIFACT="/tmp/release-${DEPLOY_SHA}.tar.gz"
            PREVIOUS_RELEASE="$(readlink -f "${CURRENT_LINK}" || true)"
            mkdir -p "${RELEASES_DIR}"
            rollback() {
              echo "Rollback triggered..."
              if [ -n "${PREVIOUS_RELEASE:-}" ] && [ -d "${PREVIOUS_RELEASE}" ]; then
                echo "Rollback target: ${PREVIOUS_RELEASE}"
                ln -sfn "${PREVIOUS_RELEASE}" "${CURRENT_LINK}"
                if [ -f "${CURRENT_LINK}/ecosystem.config.js" ]; then
                  echo "PM2 command: startOrReload ${CURRENT_LINK}/ecosystem.config.js --update-env"
                  pm2 startOrReload "${CURRENT_LINK}/ecosystem.config.js" --update-env || pm2 restart all
                elif [ -f "${CURRENT_LINK}/Server/ecosystem.config.js" ]; then
                  echo "PM2 command: startOrReload ${CURRENT_LINK}/Server/ecosystem.config.js --update-env"
                  pm2 startOrReload "${CURRENT_LINK}/Server/ecosystem.config.js" --update-env || pm2 restart all
                else
                  if pm2 describe contentflow >/dev/null 2>&1; then
                    echo "PM2 command: reload contentflow --update-env"
                    pm2 reload contentflow --update-env || pm2 restart contentflow
                  else
                    echo "PM2 command: start contentflow (fallback)"
                    pm2 start "npm run start" --name contentflow --cwd "${CURRENT_LINK}/Server"
                  fi
                fi
                pm2 save || true
              fi
              rm -rf "${NEW_RELEASE}" || true
            }
            trap rollback ERR
            rm -rf "${NEW_RELEASE}"
            mkdir -p "${NEW_RELEASE}"
            tar -xzf "${ARTIFACT}" -C "${NEW_RELEASE}"
            if [ -n "${SERVER_ENV_FILE:-}" ]; then
              printf "%s" "${SERVER_ENV_FILE}" > "${NEW_RELEASE}/Server/.env"
            fi
            if [ -n "${CLIENT_ENV_FILE:-}" ]; then
              printf "%s" "${CLIENT_ENV_FILE}" > "${NEW_RELEASE}/Client/.env.local"
            fi
            # Install production dependencies only.
            npm --prefix "${NEW_RELEASE}/Server" ci --omit=dev
            npm --prefix "${NEW_RELEASE}/Client" ci --omit=dev
            # Run migration if script exists.
            if npm --prefix "${NEW_RELEASE}/Server" run | grep -qE '^  migrate'; then
              npm --prefix "${NEW_RELEASE}/Server" run migrate
            else
              echo "No migration script found; skipping migration."
            fi
            # Switch traffic atomically to new release.
            ln -sfn "${NEW_RELEASE}" "${CURRENT_LINK}"
            # Zero-downtime reload when PM2 cluster is configured.
            if [ -f "${CURRENT_LINK}/ecosystem.config.js" ]; then
              echo "PM2 command: startOrReload ${CURRENT_LINK}/ecosystem.config.js --update-env"
              pm2 startOrReload "${CURRENT_LINK}/ecosystem.config.js" --update-env
            elif [ -f "${CURRENT_LINK}/Server/ecosystem.config.js" ]; then
              echo "PM2 command: startOrReload ${CURRENT_LINK}/Server/ecosystem.config.js --update-env"
              pm2 startOrReload "${CURRENT_LINK}/Server/ecosystem.config.js" --update-env
            else
              if pm2 describe contentflow >/dev/null 2>&1; then
                echo "PM2 command: reload contentflow --update-env"
                pm2 reload contentflow --update-env
              else
                echo "PM2 command: start contentflow (fallback)"
                pm2 start "npm run start" --name contentflow --cwd "${CURRENT_LINK}/Server"
              fi
            fi
            pm2 save
            for i in $(seq 1 20); do
              if curl -fsS "${HEALTHCHECK_URL}" >/dev/null; then
                echo "Health check passed."
                trap - ERR
                # Keep last 5 releases for quick rollback history.
                ls -1dt "${RELEASES_DIR}"/* 2>/dev/null | tail -n +6 | xargs -r rm -rf
                rm -f "${ARTIFACT}" || true
                exit 0
              fi
              echo "Health check attempt ${i}/20 failed; retrying in 3s..."
              sleep 3
            done
            echo "Health check failed."
            exit 1

  sentry_release:
    name: Sentry Release (optional)
    runs-on: ubuntu-latest
    needs:
      - deploy_pm2
    env:                                    # Define secrets as env variables for conditionals
      SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
      SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
      SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create Sentry release
        if: env.SENTRY_AUTH_TOKEN != '' && env.SENTRY_ORG != '' && env.SENTRY_PROJECT != ''
        uses: getsentry/action-release@v1
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
        with:
          version: ${{ github.sha }}
          environment: production

  notify:
    name: Notifications
    runs-on: ubuntu-latest
    needs:
      - ci
      - deploy_pm2
      - sentry_release
    if: always()

    steps:
      - name: Build deployment status message
        id: status
        shell: bash
        run: |
          RESULT="failure"
          if [ "${{ needs.deploy_pm2.result }}" = "success" ]; then
            RESULT="success"
          elif [ "${{ needs.ci.result }}" = "success" ] && [ "${{ needs.deploy_pm2.result }}" = "skipped" ]; then
            RESULT="skipped"
          fi
          MSG="Deploy result: ${RESULT} | repo: ${{ github.repository }} | branch: ${{ github.ref_name }} | sha: ${{ github.sha }} | method: pm2"
          echo "message=${MSG}" >> "$GITHUB_OUTPUT"

      - name: Notify Slack (optional)
        continue-on-error: true
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -sS -X POST -H "Content-type: application/json" \
              --data "{\"text\":\"${{ steps.status.outputs.message }}\"}" \
              "$SLACK_WEBHOOK_URL"
          else
            echo "Slack webhook not set, skipping notification."
          fi

      - name: Notify Discord (optional)
        continue-on-error: true
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          if [ -n "$DISCORD_WEBHOOK_URL" ]; then
            curl -sS -X POST -H "Content-Type: application/json" \
              --data "{\"content\":\"${{ steps.status.outputs.message }}\"}" \
              "$DISCORD_WEBHOOK_URL"
          else
            echo "Discord webhook not set, skipping notification."
          fi